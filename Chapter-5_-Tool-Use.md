# 5장. Tool Use(도구 사용 / 함수 호출) 패턴

## 5.1 도구 사용 패턴 개요

- **정의**: LLM이 외부 도구(API, 함수, DB, 코드 실행기 등)를 **호출해 자신의 한계를 보완**하는 패턴이다.
- LLM의 문제: 지식 정적·고정(학습 컷오프), 계산·실시간 데이터·작업 수행 불가.
- Tool Use로 LLM을 **“지능형 오케스트레이터”**로 변환: 도구 정의 → LLM 판단 → 함수 호출 → 실행 → 결과 반영.

### 기본 흐름

1. **도구 정의**: 이름, 설명, 매개변수 스키마(JSON 스키마 등)로 LLM이 이해할 수 있게 명시.  
2. **LLM 결정**: 사용자 쿼리 + 도구 설명 → 도구 필요성 판단.  
3. **함수 호출 생성**: LLM이 `{"name": "tool1", "args": {...}}` 같은 구조화 출력 생성.  
4. **도구 실행**: 프레임워크가 실제 함수/API 호출, 결과 반환.  
5. **LLM 처리**: 결과를 컨텍스트로 받아 최종 응답 또는 다음 단계 결정(추가 도구 호출 가능).

---

## 5.2 도구의 범위: Function vs Tool

- **Function Calling**: 미리 정의된 Python 함수 호출에 초점.
- **Tool Calling(더 포괄적)**: API 엔드포인트, DB 쿼리, **다른 에이전트 위임** 등도 포함.
- 예: 주 에이전트가 “데이터 분석” 도구로 분석 전문 에이전트에게 작업 위임.

---

## 5.3 주요 사용 사례

### 5.3.1 외부 정보 검색

- 예: 날씨 에이전트.
- 도구: 위치 입력 → 날씨 API 호출 → 현재 날씨 반환.
- 흐름: “런던 날씨?” → LLM이 날씨 도구 판단 → 위치 추출 → 호출 → 결과 → 자연어 응답.

### 5.3.2 DB·API 상호작용

- 예: e커머스 에이전트.
- 도구: 재고 조회, 주문 상태 확인, 결제 API.
- 흐름: “제품 X 재고?” → 재고 API 호출 → 수량 반환 → “재고 있음” 응답.

### 5.3.3 계산·분석 수행

- 예: 금융 에이전트.
- 도구: 계산기, 주식 API, 스프레드시트.
- 흐름: “AAPL 150달러에 100주 매수 이익?” → 주식 API → 계산기 → 수익 계산 → 응답.

### 5.3.4 커뮤니케이션 전송

- 예: 개인 비서.
- 도구: 이메일 전송 API.
- 흐름: “John에게 내일 회의 이메일 보내” → 수신자·제목·본문 추출 → API 호출.

### 5.3.5 코드 실행

- 예: 코딩 지원 에이전트.
- 도구: 샌드박스 Python 인터프리터.
- 흐름: “이 코드 기능은?” → 코드 실행 → 출력 분석 → 설명.

### 5.3.6 시스템·장치 제어

- 예: 스마트 홈 에이전트.
- 도구: 조명 제어 API.
- 흐름: “거실 불 꺼” → 명령·대상 추출 → API 호출.

---

## 5.4 구현 프레임워크별 특징

### 5.4.1 LangChain

- **도구 정의**: `@langchain_tool` 데코레이터로 Python 함수 감싸기.
- **에이전트 생성**: `create_tool_calling_agent(llm, tools, prompt)` + `AgentExecutor`로 실행 관리.
- 예: 검색 도구 시뮬레이션 → 쿼리별 미리 정의 응답 → 에이전트가 자동 호출·결합.

### 5.4.2 CrewAI

- **도구 정의**: `@tool` 데코레이터, 명확한 docstring 필수.
- **에이전트·작업**: 역할·목표·배경 설정 + 도구 할당 → Crew로 협업 워크플로.
- 예: 재무 분석가 에이전트 + `get_stock_price` 도구 → AAPL 주가 조회 작업.

### 5.4.3 Google ADK

- **내장 도구**: Google Search, Code Executor, Vertex AI Search 등 사전 구축 도구 풍부.
- **에이전트 구성**: `LlmAgent(tools=[google_search])` 등으로 간단 정의.
- 예: 검색 에이전트 → “최근 AI 뉴스?” → Google Search 자동 호출.
- 고급: **BuiltInCodeExecutor**로 수학·코드 실행, **VSearchAgent**로 데이터스토어 검색.

---

## 5.5 도구 사용의 강점과 주의점

### 강점

- LLM 지식 한계 극복(실시간·독점 데이터 접근).
- 정밀 계산·작업 수행 가능.
- **현실 세계 상호작용**: 텍스트 생성 → 실제 행동 트리거.

### 주의점

- **도구 설명의 명확성**: LLM이 언제·어떻게 호출할지 이해할 수 있게 docstring·스키마 정교화.
- **오류 처리**: 도구 실패 시 LLM이 대응할 수 있게 안내.
- **보안**: 민감 데이터 노출·잘못된 호출 방지.
- **비용·지연**: 도구 호출마다 LLM 판단 + 실행 오버헤드.

---

## 5.6 한눈에 보기

- **무엇**: LLM이 외부 도구를 판단·호출·결과 활용해 한계를 보완하는 패턴.
- **왜**: LLM만으로는 실시간 데이터·계산·작업 수행 불가 → 도구로 “행동하는 에이전트”로 업그레이드.
- **어떻게**:  
  - 도구 정의(스키마·설명) → LLM 구조화 호출 생성 → 프레임워크 실행 → 결과 컨텍스트화.
- **언제**: 날씨·주가·DB 조회, 이메일·코드 실행, 시스템 제어 등 **외부 상호작용 필요** 시.

---

## 5.7 핵심 정리

- Tool Use는 **LLM을 텍스트 생성기에서 실행 가능한 에이전트로 만드는 핵심 패턴**이다.
- LangChain·CrewAI·ADK 등은 도구 정의·호출·실행을 쉽게 추상화해준다.
- 다른 패턴(체이닝·라우팅 등)과 결합하면, 완전한 “생각·계획·행동” 에이전트 구현 가능.
