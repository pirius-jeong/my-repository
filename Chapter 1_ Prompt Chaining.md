# 1. 프롬프트 체이닝 핵심 개념

- 복잡한 문제를 작은 하위 작업들로 분해하고, 각 하위 작업을 별도 프롬프트·LLM 호출로 처리한 뒤 결과를 다음 단계의 입력으로 넘기는 구조의 패턴이다.
- 각 단계는 특정 역할과 목표(예: 요약, 엔터티 추출, 계획 수립 등)를 가지며, 이전 단계 출력에 의존하는 종속 체인을 형성한다.
- 이 방식은 “한 번에 다 하라”는 거대 프롬프트 대비 인지 부하를 줄이고, 디버깅·모니터링·실패 지점을 분리하기 쉽게 만든다.

## 1.1 단일 거대 프롬프트의 한계

- 긴 단일 프롬프트는 다음과 같은 문제를 야기하기 쉽다.
  - 지시 일부 무시
  - 컨텍스트 드리프트
  - 초기 오류의 전파
  - 환각 증가
  - 불필요하게 긴 컨텍스트 요구
- 예: “시장 조사 분석 + 요약 + 추세 파악 + 이메일 작성”을 한 번에 시키면 일부 단계(데이터 추출, 이메일 구조화 등)가 자주 실패하거나 품질이 떨어진다.

## 1.2 체이닝의 기본 아이디어

- 위와 같은 복합 작업을 다음과 같이 쪼갠다.
  - 단계 1: 원본 텍스트 요약
  - 단계 2: 요약에서 핵심 추세와 데이터 포인트 추출
  - 단계 3: 추세·데이터를 활용해 이메일 작성
- 각 단계는 역할과 입력/출력을 명확히 정의하여, “간단하지만 정확한” 작업만 수행하게 한다.
- 이렇게 분할하면 각 단계의 품질 측정과 개선이 쉬워지고, 실패 지점도 단계 단위로 격리된다.

---

# 2. 구조화된 출력과 도구 통합

## 2.1 구조화된 출력의 필요성

- 체인의 한 단계에서 생성된 출력이 모호하면 다음 단계가 제대로 동작하지 않는다.
- 이를 방지하기 위해 JSON·XML 등 구조화된 포맷을 명시하는 것이 중요하다.
- 예: 추세 식별 단계의 출력 스키마
  - `trend_name`: 추세 이름
  - `supporting_data`: 그 추세를 뒷받침하는 정량·정성 데이터
- 이렇게 스키마를 고정하면:
  - 다음 단계에서 기계적으로 파싱 가능
  - 검증 로직(필드 누락 여부, 타입 체크 등) 삽입 가능
  - 재시도/보정 로직을 자동화하기 쉽다.

## 2.2 외부 도구·시스템과의 결합

- 체인의 중간 단계에서:
  - 검색 시스템(벡터 DB, 검색엔진)
  - 비즈니스 데이터베이스
  - 계산기, 스프레드시트, 코드 실행 환경
  - 기타 도메인별 API
- 등을 호출하여 LLM이 가지지 못한 능력(정밀 계산, 실시간 데이터, 사내 데이터 접근)을 보완한다.
- 전형적인 흐름 예:
  - LLM이 “무엇을 조회해야 하는지”를 결정 → 도구 호출 → 결과를 다시 LLM에 컨텍스트로 제공 → 후속 추론/작성 수행.

---

# 3. 에이전트 개발 관점의 주요 사용 시나리오

## 3.1 정보 처리 워크플로

- 문서·URL 등 원시 텍스트를 여러 단계에 걸쳐 가공하는 패턴:
  - 텍스트 추출
  - 요약
  - 엔터티(이름, 날짜, 금액, 장소 등) 추출
  - 내부 지식베이스·API 조회
  - 요약·엔터티·조회 결과를 합쳐 보고서 생성
- 적용 사례:
  - 자동 보고서 생성 에이전트
  - 리서치 어시스턴트
  - 뉴스/논문 브리핑 에이전트

## 3.2 복잡 질의 응답

- 예시 질의: “1929년 주식 시장 붕괴의 주요 원인과, 이에 대한 정부 정책 대응은 무엇인가?”
- 처리 흐름:
  - 단계 1: 원 질문을 하위 질문(원인 / 대응)으로 분해
  - 단계 2: 원인에 대한 정보 수집·정리
  - 단계 3: 정부 대응에 대한 정보 수집·정리
  - 단계 4: 2·3단계 결과를 구조적으로 통합해 최종 답변 작성
- 특징:
  - 하위 문제 분해 후, 각 하위 문제에 대해 개별적으로 검색·추론
  - 마지막에 종합 단계가 존재하여 일관된 서술을 만든다.

## 3.3 데이터 추출·정규화·검증

- 비정형 문서(송장, 이메일, 계약서 등)에서 구조화 데이터를 얻는 반복적 체인:
  - 필드 추출(이름, 주소, 금액 등)
  - 필수 필드/형식 검증
  - 부족하거나 잘못된 항목만 재추출·수정 요청
  - 최종 구조화 데이터 출력
- 필요 시, 외부 도구로:
  - 숫자 정규화(“1,050달러” → 1050 등)
  - 계산 및 합계 검증
- OCR + LLM + 도구 호출을 결합해 “사람이 일일이 확인하던 문서 처리”를 자동화할 때 유용하다.

## 3.4 콘텐츠 생성 워크플로

- 복잡한 글쓰기 작업을 일련의 단계로 분해:
  - 아이디어 후보 생성
  - 주제 선택/랭킹
  - 상세 목차(아웃라인) 작성
  - 각 섹션별 초안 작성 (이전 섹션을 컨텍스트로 순차 진행)
  - 전체 문서의 흐름·톤·문법 일괄 정리
- 장점:
  - 사용자가 개입하기 좋은 지점(주제 선택, 아웃라인 승인 등)을 자연스럽게 제공
  - 섹션 단위 품질 관리와 재작성에 적합

## 3.5 상태를 가진 대화형 에이전트

- 대화형 에이전트에서 프롬프트 체이닝은 “대화 상태”를 유지하는 기본 메커니즘:
  - 사용자 발화 → 의도/엔터티 추출
  - 대화 상태 업데이트(사용자 목표, 진행 상황, 제약 조건 등)
  - 상태 기반 응답 생성 + 다음에 물어볼 질문 결정
- 대화가 길어질수록:
  - 상태를 별도 구조로 관리
  - 매 턴마다 이 상태를 일부만 컨텍스트로 제공
- 이를 통해:
  - 중장기 목표를 가진 대화(여행 설계, 프로젝트 계획, 학습 튜터링 등)에서도 일관성을 유지한다.

## 3.6 코드 생성 및 개선

- 코드 관련 에이전트의 일반적인 체인:
  - 요구사항 이해 및 의사코드/설계 초안 생성
  - 초기 코드 생성
  - 정적 분석·테스트 코드 생성·실행 결과로 버그/개선점 수집
  - 코드 리팩토링/수정
  - 문서화 및 예제 작성
- 각 단계 사이에:
  - 테스트 러너, linters, 타입체커 등 도구를 삽입할 수 있고,
  - LLM 호출 간에 결정론적 로직을 배치해서 안정성을 높인다.

## 3.7 멀티모달·다단계 추론

- 이미지+텍스트+표 등 다양한 양식이 섞인 입력을 처리할 때:
  - 이미지에서 텍스트 추출 (OCR, 캡션 등)
  - 추출된 텍스트를 레이블·표 구조와 매핑
  - 표 구조를 바탕으로 필요한 계산·해석 수행
- 이처럼 서로 다른 모달리티에 대해 별도의 단계를 두고, 마지막에 통합 추론을 수행한다.

---

# 4. 컨텍스트 엔지니어링 vs 프롬프트 엔지니어링

## 4.1 프롬프트 엔지니어링의 한계

- 전통적 프롬프트 엔지니어링은:
  - “질문/명령 문장을 어떻게 잘 쓰느냐”에 초점을 둔다.
  - 단일 대화 턴, 단일 요청 기준 최적화에 가까운 접근이다.
- 복잡한 에이전트 시스템에서는:
  - 질문 문장만 잘 다듬어서는 원하는 성능이 나오지 않는다.
  - 모델이 어떤 환경·데이터·도구에 둘러싸여 있는지가 더 중요해진다.

## 4.2 컨텍스트 엔지니어링의 정의

- 컨텍스트 엔지니어링은:
  - 토큰 생성 전에 모델에 제공되는 전체 정보 환경을 설계·구축·공급하는 방법론이다.
- 포함되는 주요 계층:
  - 시스템 프롬프트(역할, 톤, 제약 조건, 정책)
  - 검색된 문서·지식베이스 결과
  - 도구/API 호출 결과(실시간 데이터, 캘린더, CRM 등)
  - 사용자 프로필, 과거 대화, 환경 상태 등 암묵적 데이터
- 관점의 전환:
  - “질문에 답하게 한다” → “특정 상황에서 행동하는 에이전트를 위한 운영 맥락을 구성한다”.

## 4.3 컨텍스트 엔지니어링의 실무 포인트

- 런타임 파이프라인:
  - 언제 어떤 외부 데이터를 가져올지 결정
  - 가져온 데이터를 어떻게 요약·정규화해 컨텍스트로 넣을지 정의
  - 컨텍스트 길이 제한을 고려한 우선순위·압축 전략 설계
- 피드백 루프:
  - 에이전트 출력 품질을 평가하는 메트릭 정의
  - 예시 입력/출력 로그를 기반으로 컨텍스트 구성 방식을 자동 또는 반자동으로 개선
- 이 과정을 자동화해주는 도구(프롬프트/컨텍스트 옵티마이저 등)를 활용하면,
  - 다양한 모델·시나리오에 대해 일관된 개선 사이클을 만들 수 있다.

---

# 5. 프레임워크와 패턴 선택 가이드

## 5.1 주요 프레임워크 개요

- LangChain
  - 선형 체인, LCEL 기반 구성에 적합
  - 단순한 순차 파이프라인을 빠르게 구현하는 데 유리
- LangGraph
  - 상태 기반, 루프, 조건 분기 등을 그래프 형태로 모델링
  - 보다 복잡한 에이전트 동작·워크플로에 적합
- 기타
  - CrewAI, Google ADK 등도 작업 단위/역할 단위 구성에 초점을 둔 프레임워크를 제공

## 5.2 언제 프롬프트 체이닝을 쓸 것인가

- 다음과 같은 조건 중 하나 이상을 만족하면 프롬프트 체이닝을 고려한다.
  - 단일 프롬프트로 처리하기에는 작업이 너무 복잡하다.
  - 여러 개의 명백한 처리 단계가 존재한다.
  - 단계들 사이에 외부 도구 호출, 검증, 조건 분기가 필요하다.
  - 다단계 추론과 상태 유지가 필요한 에이전트를 설계하고 있다.
- 에이전트 아키텍처에서의 위치:
  - 체이닝은 “계획–실행–검증–수정”이라는 더 큰 루프의 내부에서
  - 세부 워크플로를 구성하는 기본 패턴으로 활용된다.


