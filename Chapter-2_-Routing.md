# 2. 라우팅(Routing) 패턴

## 2.1 라우팅의 핵심 개념

- **정의**: 프롬프트 체이닝의 선형적 처리를 벗어나, 에이전트가 입력·상태·이전 결과를 평가하여 **여러 가능한 후속 작업 중 가장 적합한 경로를 동적으로 선택**하는 메커니즘이다.
- 고정된 실행 순서 대신 **조건부 논리**를 도입해 상황 인식적 시스템을 만든다.
- 예시: 고객 문의 → 의도 분석 → (주문 확인 / 제품 정보 / 기술 지원 / 기타)로 분기

## 2.2 라우팅의 동작 원리

- 사용자 쿼리를 분석하여 그 의도(intent)를 파악한다.
- 식별된 의도에 따라 다음 중 하나를 선택한다:
  - **특정 하위 에이전트/도구** 호출 (예: 주문DB 조회, 상품 카탈로그 검색)
  - **워크플로 체인** 전환 (예: 문제 해결 가이드 제공 또는 인간 에스컬레이션)
  - **재질문** (의도가 불분명한 경우)

---

## 2.3 라우팅 메커니즘 구현 방식

### 2.3.1 LLM 기반 라우팅
- LLM 자체가 입력을 분석하여 **카테고리/식별자**를 출력하도록 프롬프트한다.
- 예: "다음 중 하나만 출력: '주문_상태' / '제품_정보' / '기술_지원' / '기타'"
- **장점**: 미묘한 의도 차이도 포착 가능, 유연성 높음
- **단점**: LLM 호출 비용 증가, 응답 시간

### 2.3.2 임베딩 기반 라우팅
- 입력 쿼리를 벡터 임베딩으로 변환하고, 각 라우팅 경로를 나타내는 임베딩과 비교한다.
- 가장 유사한 경로로 라우팅한다.
- **장점**: 의미 기반 라우팅, 키워드 매칭보다 유연함
- **단점**: 임베딩 생성 비용, 경로별 참조 임베딩 유지 필요

### 2.3.3 규칙 기반 라우팅
- 입력에서 추출한 키워드, 패턴, 구조화된 데이터에 기반한 if-else, switch-case 논리
- **장점**: 빠르고 결정론적
- **단점**: 미묘한 사례나 새로운 입력에 유연성 부족

### 2.3.4 머신러닝 모델 기반 라우팅
- 작은 레이블 데이터로 학습한 분류기(classifier)를 사용한다.
- 모델 가중치 내에 라우팅 로직을 인코딩한다.
- LLM은 학습 데이터 보강용 합성 데이터 생성에만 사용 (실시간 라우팅 결정에는 X)
- **장점**: 정확도 높음, 배포 후 고정적 성능
- **단점**: 학습 데이터 준비 필요, 새로운 클래스 적응 어려움

---

## 2.4 라우팅의 적용 시점

에이전트 운영 주기 내 세 가지 주요 시점:

1. **초기 분류 단계**
   - 들어온 작업을 대분류하여 주요 워크플로를 결정
   - 예: 영업 리드 / 기술 문제 / 일반 문의

2. **중간 체인 내 분기**
   - 처리 과정 중간에 다음 단계를 결정
   - 예: 요약 후 → 긴급 여부에 따라 에스컬레이션 vs 일반 처리

3. **도구 선택 로직**
   - 주어진 도구 세트 중 가장 적합한 도구를 선택
   - 예: 텍스트 분석 / 이미지 분석 / 시계열 데이터 분석

---

## 2.5 프레임워크별 라우팅 구현 차이

### LangChain + LangGraph 방식
- **RunnableBranch** 등을 사용한 **그래프 기반 구조**
- 라우터 프롬프트 → 의사결정 → 분기 선택 → 해당 핸들러 실행
- 상태 누적이 필요한 복잡한 라우팅에 적합
- 계산 그래프로 전체 흐름을 시각화할 수 있음

### Google ADK 방식
- **도구(Tool) 기반 위임**
- Coordinator 에이전트가 sub_agents를 정의
- 각 sub_agent는 특정 기능(도구)를 보유
- ADK의 자동 흐름(automatic flow) 메커니즘이 LLM을 통해 자동으로 위임 처리
- 명시적 계산 그래프 구성 불필요, 더 선언적 방식

---

## 2.6 실제 사용 시나리오

### 2.6.1 인간-컴퓨터 상호작용
- 가상 비서, AI 튜터, 챗봇
- 자연어 질의 → 의도 분석 → (정보 검색 도구 호출 / 인간 오퍼레이터 연결 / 다음 교육 모듈 선택)

### 2.6.2 자동화된 데이터·문서 처리
- 이메일, 지원 티켓, API 페이로드 분류
- 각 항목을 해당 워크플로로 배분
  - 영업 리드 처리
  - JSON/CSV 형식 변환
  - 긴급 문제 에스컬레이션

### 2.6.3 다중 전문 도구/에이전트 시스템
- 정보 검색·요약·분석 기능을 가진 여러 에이전트
- 라우터가 현재 목표에 맞는 에이전트를 선택
- 예: AI 코딩 어시스턴트 → 프로그래밍 언어 & 의도 파악 → 적절한 도구에 전달

---

## 2.7 라우팅과 체이닝의 조합

- **병렬 처리 + 순차 처리 혼합**
  - 예: 여러 논문에서 핵심 정보를 **병렬로** 추출 → **순차적으로** 종합 및 정리
- **다단계 프롬프트 체이닝 + 라우팅**
  - 각 체인 단계 사이에 조건부 라우팅 삽입
  - 상태나 중간 결과에 따라 다음 체인을 선택

---

## 2.8 주요 장점

1. **상황 인식성**: 입력과 상태에 따라 동적으로 행동 선택
2. **모듈성**: 각 워크플로/도구가 독립적으로 최적화 가능
3. **확장성**: 새로운 경로나 도구 추가 용이
4. **효율성**: 불필요한 단계 스킵, 목표에 맞는 경로만 실행
5. **견고성**: 단계별 실패 격리, 디버깅 용이

---

## 2.9 한눈에 보기

**무엇**: 에이전트가 고정된 실행 경로를 벗어나 **입력과 상태에 따라 여러 워크플로 중 가장 적합한 경로를 선택**하는 메커니즘

**왜**: 
- 단순 순차 처리로는 실제 다양한 사용자 요청을 처리하기 어려움
- 라우팅을 통해 조건부 논리를 도입해 **정적 실행자 → 동적 의사결정 시스템**으로 전환

**언제**: 
- 에이전트가 여러 워크플로/도구 중 선택해야 할 때
- 수신 요청을 분류하고 다양한 유형의 작업을 처리해야 할 때
- 사용자 의도나 현재 상태가 다음 행동을 결정할 때

---

## 2.10 주요 내용 요약

- 라우팅은 조건 기반 워크플로 선택 메커니즘이다.
- LLM, 임베딩, 규칙, ML 모델 등 다양한 구현 방식이 있다.
- LangGraph는 그래프 기반, Google ADK는 도구 기반 접근을 제공한다.
- 고객 서비스, 데이터 처리, 멀티 에이전트 시스템 등 광범위한 응용이 가능하다.
- 프롬프트 체이닝과 결합하면 더욱 강력한 에이전트 아키텍처를 구성할 수 있다.

---

## 2.11 결론

라우팅 패턴은 **고정된 실행 시퀀스를 벗어나 지능적 의사결정이 가능한 진정한 적응형 에이전트**를 만드는 필수 요소다. 입력을 분석하고 상황에 맞는 최적의 행동을 선택함으로써, 에이전트는 단순 자동화 도구에서 **복잡한 실무 요청에 대응하는 지능형 시스템**으로 진화한다.


