# 3장. 병렬화(Parallelization) 패턴

## 3.1 병렬화 패턴 개요

- **정의**: 서로 **독립적인 하위 작업을 동시에 실행**하여 전체 워크플로의 지연 시간을 줄이는 패턴이다.
- 프롬프트 체이닝(순차), 라우팅(분기)만으로는, “여러 일을 동시에 할 수 있는” 상황에서 성능을 충분히 끌어올리기 어렵다.
- 병렬화는 LLM 호출, 도구 호출, 하위 에이전트 실행 등을 **동시(concurrent)** 또는 **병렬(parallel)**로 수행하도록 워크플로를 설계하는 것이다.

### 순차 vs 병렬 예시

- 순차 연구 에이전트:  
  1) 소스 A 검색 → 2) 소스 A 요약 → 3) 소스 B 검색 → 4) 소스 B 요약 → 5) A/B 종합  
- 병렬 연구 에이전트:  
  1) 소스 A/B를 동시에 검색 → 2) 두 검색 완료 후 A/B를 동시에 요약 → 3) A/B 요약을 종합  
- 핵심: **서로 의존하지 않는 단계**를 식별해 동시에 실행한다.

---

## 3.2 병렬화가 특히 유효한 상황

- 외부 I/O(네트워크, DB, API)를 여러 번 호출해야 할 때, 각 호출을 순차로 기다리면 지연이 누적된다.
- 서로 다른 데이터 세그먼트/소스에 대해 동일·유사한 처리를 반복할 때.
- 하나의 최종 응답을 만들기 전에 여러 “부분적인 결과”를 모아야 할 때.

---

## 3.3 대표 사용 사례

### 3.3.1 정보 수집·연구 에이전트

- 예: 특정 회사를 조사하는 에이전트.
- 병렬 작업:  
  - 뉴스 검색  
  - 주가/재무 데이터 조회  
  - 소셜 미디어 언급 분석  
  - 사내 DB 질의  
- 효과: 같은 시간에 더 많은 소스를 커버, “리서치 대기 시간” 단축.

### 3.3.2 데이터 처리·분석

- 예: 고객 피드백 분석 에이전트.
- 병렬 작업:  
  - 감성 분석  
  - 키워드 추출  
  - 카테고리 분류  
  - 긴급 이슈 감지  
- 효과: 하나의 피드백 세트에 대해 다각도 분석을 빠르게 제공.

### 3.3.3 다중 API·도구 호출

- 예: 여행 플래너.
- 병렬 작업:  
  - 항공권 검색  
  - 호텔 가용성 조회  
  - 현지 이벤트 정보  
  - 레스토랑 추천  
- 효과: 사용자에게 “한 번에 완성된” 결과를 빠르게 보여줄 수 있음.

### 3.3.4 콘텐츠 생성

- 예: 마케팅 이메일 생성 에이전트.
- 병렬 작업:  
  - 제목(Subject line) 후보 생성  
  - 본문 초안 작성  
  - 이미지 후보 탐색/설명  
  - CTA 버튼 문구 생성  
- 효과: 구성요소를 미리 다 만들어둔 뒤 최종 조립만 순차적으로 진행.

### 3.3.5 검증·검사

- 예: 사용자 입력 검증 에이전트.
- 병렬 작업:  
  - 이메일 형식 체크  
  - 전화번호 형식 및 국가별 규칙 체크  
  - 주소 DB 매칭  
  - 욕설/금지어 필터링  
- 효과: “한 번에” 검증 결과를 반환하여 UX 개선.

### 3.3.6 멀티모달 처리

- 예: 텍스트+이미지가 함께 있는 SNS 게시물 분석.
- 병렬 작업:  
  - 텍스트 감성 분석, 키워드 추출  
  - 이미지 객체 인식, 장면 설명  
- 효과: 각 모달리티를 독립적으로 처리한 뒤, 나중에 통합.

### 3.3.7 A/B 테스트·다중 옵션 생성

- 예: 헤드라인/카피 여러 버전 생성 에이전트.
- 병렬 작업:  
  - 서로 다른 프롬프트/모델 설정으로 여러 헤드라인 동시 생성  
- 효과: 생성 시간을 늘리지 않고 선택지를 확보, 자동 평가·선택 단계와 결합 가능.

---

## 3.4 구현 관점: 프레임워크별 병렬화

### 3.4.1 LangChain / LCEL

- LCEL에서 **여러 Runnable을 dict/list 구조에 넣어 전달**하면, 해당 Runnable들이 동시에 실행된다.
- 예시 패턴:  
  - `RunnableParallel`을 사용해 `{"summary": chain1, "questions": chain2, "terms": chain3}` 처럼 구성  
  - 이후 결과를 하나의 합성 프롬프트로 넘겨 최종 응답 생산  
- 비동기 실행(`ainvoke`)과 결합하여, I/O 대기 시간을 효율적으로 사용한다.

### 3.4.2 LangGraph

- 그래프 토폴로지 기반:  
  - 하나의 노드에서 여러 노드로 분기 → 서로 의존성이 없는 노드들이 병렬 실행 → 이후 합류 노드에서 결과 집계.
- 상태 기반 그래프라서, 병렬 분기 간에도 공통 상태를 공유·갱신할 수 있다.

### 3.4.3 Google ADK

- **ParallelAgent**: 여러 하위 에이전트를 동시에 실행, 각 결과를 세션 상태에 저장.
- **SequentialAgent**: 먼저 ParallelAgent를 실행해 상태를 채운 뒤, 이후 Merger 에이전트 등 후속 단계를 순차 실행.
- 전형적인 패턴:  
  1) ParallelAgent: 여러 LlmAgent가 각자 Google Search 등 도구를 활용해 병렬 연구 수행  
  2) Merger LlmAgent: 상태에 쌓인 결과만을 근거로 구조화된 보고서 작성  
  3) SequentialAgent: (1) → (2)를 하나의 파이프라인으로 오케스트레이션

---

## 3.5 병렬화 설계 시 고려사항

- **독립성 판단**:  
  - 서로의 출력에 의존하지 않는 작업만 병렬화해야 한다.
  - 종속 관계가 있으면 체이닝(순차) 패턴을 사용한다.
- **복잡도 증가**:  
  - 동시성/병렬성은 설계·디버깅·로깅 복잡도를 높인다.  
  - 실패 시 재시도, 부분 실패 처리, 타임아웃 전략 등이 필요.
- **성능–복잡도 트레이드오프**:  
  - 항상 병렬화가 이득인 것은 아니다.  
  - 작업 수, I/O 비중, 인프라 제약 등을 고려해 “병렬화할 가치가 있는 부분”만 선택해야 한다.

---

## 3.6 한눈에 보기

- **무엇**: 서로 의존하지 않는 여러 하위 작업(LLM 호출, 도구 호출, 하위 에이전트)을 동시에 실행하는 패턴.
- **왜**: 외부 I/O나 여러 소스·세그먼트 작업이 많은 워크플로에서 전체 지연 시간을 크게 줄이기 위해.
- **언제**:  
  - 여러 API/DB에서 데이터를 가져올 때  
  - 데이터 청크/소스를 병렬로 처리할 수 있을 때  
  - 나중에 한 번에 합성할 여러 콘텐츠를 생성할 때.
- **어떻게**:  
  - LangChain: `RunnableParallel` 등  
  - LangGraph: 병렬 노드 + 합류 노드  
  - Google ADK: ParallelAgent + SequentialAgent 조합으로 구현.

---

## 3.7 핵심 정리

- 병렬화는 **에이전트 시스템의 성능·응답성 최적화**를 위한 기본 패턴이다.
- 체이닝(순차)·라우팅(조건 분기)과 결합하면, 복잡한 에이전트 워크플로를 **고성능·고유연성** 구조로 설계할 수 있다.
