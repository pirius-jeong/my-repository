# 8장. Memory Management(메모리 관리)

## 8.1 메모리 관리 패턴 개요

- **정의**: 에이전트가 **단기(즉시) + 장기(지속)** 메모리를 통해 과거 정보 유지·활용하는 패턴이다.
- **왜 필요?** LLM은 stateless(stateless) → 메모리 없으면 맥락 잊음, 개인화·학습·연속성 불가.
- **인간 메모리 유사**: 단기(작업 기억) + 장기(사실·경험·규칙).

### 메모리 유형

| 유형 | 특징 | 저장소 | 용도 | 한계 |
|------|------|--------|------|------|
| **단기(Short-term)** | 현재 대화 맥락 | LLM 컨텍스트 창 | 최근 메시지·도구 결과·성찰 | 용량 제한, 세션 종료 시 소실 |
| **장기(Long-term)** | 지속 정보 | 벡터 DB·지식 그래프·DB | 사용자 선호·과거 경험·지식 | 검색 효율성 중요 |

---

## 8.2 메모리 유형 상세

### 8.2.1 단기 메모리(맥락적·작업 기억)

- **LLM 컨텍스트 창**: 최근 메시지·도구 결과·성찰 저장 → 후속 응답 영향.
- **관리 기법**:  
  - 오래된 대화 요약.  
  - 주요 정보만 강조.  
  - 장기 맥락 모델(큰 창) 활용.
- **문제**: 비용 ↑, 세션 종료 시 소실 → 장기 메모리 보완 필요.

### 8.2.2 장기 메모리(지속 기억)

- **외부 저장소**: DB, 지식 그래프, **벡터 DB**(임베딩으로 의미 검색).
- **검색 과정**: 쿼리 → 관련 데이터 검색 → 단기 컨텍스트 통합.
- **세부 유형**:  
  - **의미 기억(사실)**: 사용자 선호·도메인 지식(JSON 프로필·컬렉션).  
  - **에피소드 기억(경험)**: 과거 성공/실패 사례(few-shot 예시).  
  - **절차적 기억(규칙)**: 시스템 프롬프트(반사로 동적 업데이트).

---

## 8.3 응용 사례

- **챗봇**: 단기(대화 흐름) + 장기(선호도·과거 문제).
- **작업 에이전트**: 단기(진행 상황) + 장기(사용자 데이터).
- **개인화**: 장기(행동·선호도)로 맞춤 응답.
- **학습·개선**: 장기(성공 전략·실수)로 적응.
- **RAG(검색 증강 생성)**: 장기 지식 기반 검색.
- **자율 시스템**: 단기(주변 환경) + 장기(지도·학습 행동).

---

## 8.4 구현: Google ADK

### 8.4.1 세션(Session)

- **역할**: 개별 채팅 스레드 추적(메시지 기록 + 임시 데이터).
- **구성 요소**: ID, 이벤트 기록, 상태(state), 타임스탬프.
- **SessionService**: 생성·기록·종료 관리.
  - **InMemory**: 테스트용(재시작 시 소실).  
  - **Database**: SQLite/PostgreSQL 등 지속성.  
  - **VertexAI**: GCP 확장성.

### 8.4.2 상태(State)

- **session.state**: 세션별 **임시 데이터 사전**(키-값).
- **접두사 규칙**:  
  | 접두사 | 범위 | 지속성 | 예시 |
  |--------|------|--------|------|
  | (없음) | 세션 | 세션 종료 소실 | `task_status` |
  | `user:` | 사용자 전 세션 | 지속 | `user:login_count` |
  | `app:` | 앱 전체 | 지속 | `app:global_config` |
  | `temp:` | 현재 턴 | 턴 종료 소실 | `temp:validation_needed` |
- **업데이트 방법**:  
  1. **output_key**: 에이전트 텍스트 응답 자동 저장(간단).  
  2. **EventActions.state_delta**: 이벤트 시 상태 변경 명시(복잡 업데이트).

### 8.4.3 메모리(MemoryService)

- **역할**: 장기 지식 저장·검색.
- **구현**:  
  - **InMemoryMemoryService**: 테스트용.  
  - **VertexAiRagMemoryService**: 벡터 검색 + RAG(프로덕션).
- **사용**: `add_session_to_memory(session)` → 세션 정보 자동 저장·검색.

---

## 8.5 구현: LangChain / LangGraph

### 8.5.1 단기 메모리

- **ChatMessageHistory**: 수동 대화 기록 관리.
- **ConversationBufferMemory**: 체인 자동 통합.  
  - `memory_key="history"`: 프롬프트 변수.  
  - `return_messages=True`: 채팅 모델용 메시지 목록.

### 8.5.2 장기 메모리

- **LangGraph BaseStore**: JSON 문서 저장(네임스페이스 + 키).
- **예시**: 사용자 선호도 저장 → 의미 검색 → 프롬프트 통합.
- **반사 업데이트**: 과거 대화 반영해 시스템 프롬프트 동적 수정.

---

## 8.6 Vertex AI Memory Bank(관리형 서비스)

- **기능**: Gemini로 대화 분석 → 사실·선호도 자동 추출·저장·업데이트.
- **범위**: 사용자 ID 기반, 모순 해결 자동.
- **통합**: ADK·LangGraph·CrewAI 지원.
- **강점**: 즉시 사용 가능, 영구 장기 메모리.

---

## 8.7 설계 팁

- **단기**: 컨텍스트 최적화(요약·압축).
- **장기**: 벡터 DB + 의미 검색(RAG).
- **상태 업데이트**: `output_key` 또는 `state_delta` 사용, 직접 사전 조작 X.
- **접두사 활용**: 범위·지속성 명확화.
- **트레이드오프**: 기억 ↑ → 비용·지연 ↑, 관련성 높은 정보만 유지.

---

## 8.8 한눈에 보기

- **무엇**: **단기(컨텍스트) + 장기(지속)** 메모리로 과거 정보 유지·활용.
- **왜**: Stateless LLM → 맥락·개인화·학습 불가 → 메모리로 연속성 확보.
- **어떻게**:  
  - ADK: Session·State·MemoryService.  
  - LangChain: BufferMemory·BaseStore.  
  - Vertex: 자동 추출·관리.
- **언제**: 대화 지속·작업 추적·사용자 개인화 필요 시.

---

## 8.9 핵심 정리

- 메모리 관리는 **stateless LLM을 상태 인식 에이전트로 만드는 기반**이다.
- 단기(현재 대화) + 장기(지속 지식) 균형 설계가 핵심.
- ADK·LangGraph 등은 실무적 구현 쉽게 지원.
